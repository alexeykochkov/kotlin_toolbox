// Важно про так называемые парадигмы. Это принципиальныо разные стили написания кода, хотя их миксуют как хотят
// 1. Процедурное/структурное - считается устаревшим, это как первые твои домашки
// 2. [!] ООП (Объектно ориентированное программирование) - сейчас это топ. Это про классы, методы и тп
//     Связанные слова - инкапсуляция/сокрытие деталей реализации (private/public/protected), полиморфизм (потом обхясню), наслелование (тоже потом)
//     Исключения - базовые/сильные(strong)/nofail гарантии исключений
// 3. Функциональное - убийца ООП. Это лямбды, map/flatmap/filter/etc - это новое, относительно. Вижу что в котлине довольно много используется


class Tv constructor(model: String, diag: Int) {  // Главный конструктор. Его реализация - init блок
    // Private section - я обычно ее пишу внизу класс, но в Котлине так нельзя, отстой
    private val kModel_: String  // k* - константа, это гугловый кодостайл для С++, для Java обычно пишут - MODEL_
    private val kDiag_: Int // Константы можно задать только при констуировании, и изменить уже нельзя. Это очень хорошо
    
    
    // Attention!!! В этой var, не val, кроется ответ почему программы писать сложно, и одна из причин больших зарплат
    // Такие переменные которые созхраняют значение между вызовами методов ОЧЕНЬ сильно усложнают софт - тестирование, деплой, дебаг
    // Их должно быть по минимуму, с ними связаны так называемы инварианты и состояние. Вызывая set-методы мы меняем стейт, а значит
    // количество вариантов выполнения программы и нахождения в кривых состояниях вырастает космически.
    // 
    // Attention!!! ВСЕ var-переменные образуют ЕДИНОЕ состояние объекта
    private var powerOn_ = false
    private var channel_ = 0
    private var mark_ = "LG"  // Не получилось сделать константу и заинитить вторым конструктором
    
    // Public - все публичное первый
    init {
    	kDiag_ = diag
        kModel_ = model
    }
    
    constructor(model: String, diag: Int, mark: String) : this(model, diag) {
        mark_ = mark  // не смог присвоить константе
    }
    
    // get-метод/геттер - это хорошо
    fun getDiag() : Int {
        return kDiag_;
    }
    
    fun getMark() : String {
        return mark_;  // Про этот пример расскажу отдельно, тут есть пруф, почему состояние опасно, тут дыра в безопасности
    }
    
    // set-метод/сеттер - это плохо - меняет состояние после конструирования, это риск почти всегда. Больше конструкторов и геттеров, минимизировать сеттеры
    // Про immutability - https://www.yegor256.com/2016/09/07/gradients-of-immutability.html
    fun powerOn() {
        //=====================================
        // Проверяем все что сможем до того как сменим состояние. Что не так - бросаем исключение, выходим материмся в лог
        // 
        // Можно проверить текущее состояние и ничего не делать
        // Не хочется менять состояние без нужды
        if (powerOn_) {
            println("Tv: Is on now")
            return;
        }
        
        //=====================================
        // Деморкационная линия. Все что ниже - меняет состояние. Нужно дополнительное внимание. Ключевое слово - транзакция
        
        powerOn_ = true; 
    }
    
    // Операция может зафейлится, состояние может быть изменено
    fun setChannelBasicExceptionGuaranty(channel: Int) {
        // Проверяем аргументы
        // https://www.baeldung.com/kotlin/exception-handling
        if (channel < 0) throw IllegalArgumentException("Channel should be >= 0")  // Оповещаем пользователя, что он не прав. Мсключение проигнорить не может
        
        //====================================
        // Деморационная линия. Все что ниже меяет состояние
        // 
        powerOn();
        channel_ = channel
    }
    
    // Операция может зафейлится, состояние останется предыдущим
    fun setChannelStrongExceptionGuaranty(channel: Int) {
        // Потом
    }
    
    fun getPowerOn() : Boolean {
        return powerOn_
    }
    
    // Protected - это будет понятно потом, это про наследование. Потом
}

//=============================================================================

fun unit_tests() {
    // Хорошо делать много конструкторов и геттеров
    // Главынй конструктор
    run {
        val kDiag = 1
        val tv = Tv("f", kDiag)  // констуркто создает реальный объект в памяти - инстанс (Instance)
        check(tv.getDiag() == kDiag)
        check(tv.getMark() == "LG")
        check(tv.getPowerOn() == false)
    }
    
    // Вспомогательный
    run {
        // Аргументы констуктора
        val kDiag = 1
        val kMark = "Zarya"
        
        // Вызов конструктора
        val tv = Tv("f", kDiag, kMark)  // констуркто создает реальный объект в памяти - инстанс (Instance)
        
        // Проверка постусловий вызова конструктора
        check(tv.getDiag() == kDiag)
        check(tv.getMark() == kMark)
        check(tv.getPowerOn() == false)
    }
    
    // Теперь про сеттеры - это уже сложнее
    
    // Проверем включение
    run {
        val kDiag = 1
        val tv = Tv("f", kDiag)
        
        check(tv.getPowerOn() == false)  // поверка предусловия - когда только создали должен быть выключен
        tv.powerOn()
        check(tv.getPowerOn() == true)  // проверка постусловия - должен быть включен
        tv.powerOn()  // состояние не изменит
    }
    
    run {
        val kDiag = 1
        val tv = Tv("f", kDiag)
        
        check(tv.getPowerOn() == false)  // поверка предусловия - когда только создали должен быть выключен
        try {
        	tv.setChannelBasicExceptionGuaranty(-1)
        } catch(e : IllegalArgumentException) {
            check(true)
        }
        check(tv.getPowerOn() == false)  // проверка постусловия - должен быть включен
    }
}

fun app() {
    // Do real work/money
    // Взаимодействия с пользователями, базами данных итп
}

fun subsystems_tests() {
    val shopRow = mutableListOf<Tv>(Tv("a", 90), Tv("ff", 9))
    
    // Включить все 
    for (i in shopRow.indices) {
        shopRow[i].powerOn()
    }
}

//=============================================================================

fun main() {
    // По процессам
    // 1. Задание разбивается на части и на подзадания
    
    // 2. Потом реализация и проверка почастям
    // Есть разные уровни тестирования - юнит, системные, end-to-end
    // Это будет для юниттестов. Тестируем некоторые usecases (случаи использования)
    // Так же проверям что не сломали ничего при добавлении нового (регрессионное тестирование)
	unit_tests()
    
    // 3. Системные тесты, большими кусками
    subsystems_tests();
    
    // 4. Реальное боевое приложение
    app()
}